## 共享资源技术

共享内存对象、tmpfs 文件系统和共享库 .so 都是 Linux 系统中常见的技术，但它们的用途和工作方式有所不同。

*共享内存对象*：这是一种进程间通信（IPC）机制，允许两个或更多进程共享一块内存区域。共享内存是最快的 IPC 方法，因为它允许两个进程直接读写同一块内存区域，无需进行复制或上下文切换。在 Linux 中，共享内存对象可以通过 shmget、shmat 和 shmdt 等系统调用进行创建和管理。

*tmpfs 文件系统*：这是一种使用内存作为存储介质的文件系统。tmpfs 文件系统中的文件实际上是存储在 RAM 或交换空间中的，因此读写速度非常快。tmpfs 文件系统常用于存储临时文件，例如 /tmp 或 /run 目录。虽然 tmpfs 文件系统中的文件存储在内存中，但是它们表现得就像存储在磁盘上的普通文件一样，可以使用常规的文件 I/O 系统调用进行操作。

*共享库 .so*：这是一种包含可由多个程序共享的代码和数据的二进制文件。当一个程序被链接到一个共享库时，它并不需要将库中的所有代码和数据复制到自身的二进制文件中，而是在运行时动态地加载和链接这些代码和数据。这可以减少程序的大小，并允许在不重启程序的情况下更新库。在 Linux 中，共享库文件通常有 .so（Shared Object）扩展名。

总的来说，这三种技术都涉及到共享资源（内存或代码），但它们的用途和工作方式有所不同

## 链接库

*编译时库*：这些库在软件或库的编译阶段被使用。它们通常包含一些头文件和静态库，这些文件定义了函数、类和其他类型的接口，以及可能的一些内联函数和模板。编译器在编译源代码时需要这些文件，以便知道如何生成正确的机器代码。

*运行时库*：这些库在软件或库的运行阶段被使用。它们通常包含一些动态链接库（在Windows上是.dll文件，在Unix-like系统上是.so文件），这些文件包含了实现了编译时库中定义的接口的函数和对象的实际代码。当你运行一个程序时，操作系统会负责加载这些动态链接库，并将程序中的函数调用链接到库中的相应函数。

对于CUDA来说，CUDA Toolkit包含了CUDA的编译时库和运行时库。编译时库包括了CUDA的头文件和一些用于编译CUDA代码的工具，如nvcc编译器；运行时库包括了CUDA的动态链接库，这些库在运行CUDA程序时被加载。

## 链接

静态链接和动态链接是两种不同的程序链接方式，是否生成自包含可执行的二进制文件看作是静态链接和动态链接的分界线。静态链接主要由编译器（更准确地说是链接器，它是编译器套件的一部分）完成。动态链接则主要由操作系统的动态链接器（也称为加载器）完成。

#### 静态链接：

*编译*：源代码被编译器编译成对象文件。每个源文件生成一个对象文件，这些文件包含了源文件中定义的函数和变量的机器代码。

*解析符号引用*：链接器查看所有的对象文件和库，找出所有的符号引用（例如函数调用和全局变量引用）。链接器会找出这些符号在哪个对象文件或库中定义，并将引用替换为这些定义的地址。

*合并*：链接器将所有的对象文件和库合并成一个单独的可执行文件。这个文件包含了所有的代码和数据，以及程序运行所需的信息（例如程序入口点的位置）。

*重定位*：由于合并过程可能会改变代码和数据的位置，链接器需要更新所有的地址引用，使它们指向正确的位置。这个过程称为重定位。

#### 动态链接：

*编译*：源代码被编译器编译成对象文件。这个过程和静态链接的编译过程是一样的。

*生成动态链接库*：链接器将一些对象文件链接成一个动态链接库（例如.so文件在Unix系统，.dll文件在Windows系统）。这个库包含了这些对象文件的代码和数据，但不包含主程序代码。

*生成可执行文件*：链接器将主程序的对象文件链接成一个可执行文件。这个文件包含了主程序的代码和数据，以及对动态链接库的引用，但不包含库的代码和数据。

*运行时链接*：当程序运行时，动态链接器（也称为加载器）会加载程序所需的动态链接库，并将程序中的库引用替换为库中的实际地址。这个过程在程序每次运行时都会发生。

静态链接的优点是生成的可执行文件是自包含的，不依赖于外部的库，因此更易于分发。而动态链接的优点是多个程序可以共享同一个库，节省内存和磁盘空间，且当库更新时，程序无需重新链接。
