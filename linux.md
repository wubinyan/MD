## 接口

内核接口、系统调用和库函数可以被视为在不同层级上提供服务的接口，它们分别与内核、操作系统和容器（或更广义的说，用户空间应用）相关。以下是一些详细的解释：

* **内核接口(Kernel Interfaces)**：这是最底层的接口，由操作系统内核提供。内核接口直接与硬件交互，负责管理和控制硬件资源。这些接口主要由内核自身的各个部分以及一些底层系统软件（如设备驱动）使用。

* **系统调用(System Calls)**：系统调用是内核提供给用户空间程序的接口。通过系统调用，用户空间的程序可以请求内核提供的服务，如文件操作、进程管理、网络通信等。系统调用是用户空间和内核空间之间的桥梁。

* **库函数(Library Functions)**：库函数是在用户空间提供的接口，它们通常是对系统调用的封装。通过使用库函数，应用程序可以更方便地使用操作系统的功能。库函数可以是标准库提供的，也可以是其他第三方库提供的。

这三种接口在层级上是逐渐升高的：内核接口最底层，直接与硬件交互；系统调用位于中间层，为用户空间程序提供服务；库函数最高层，为应用程序提供友好和方便的接口。而在*编译*过程中，编译器会将源代码与*库函数*链接在一起，形成一个可执行文件

## 库函数

* **编译时库（Compile-time Libraries）**：当你编译一个程序时，编译器会将程序代码与编译时库中的代码合并，形成一个完整的可执行文件。这意味着编译时库的代码被直接嵌入到最终的可执行文件中。静态库（例如 .a 文件在Unix-like系统中）就是一种典型的编译时库。
优点是可执行文件通常更加独立，因为它包括了所有必要的代码。缺点是如果多个程序使用相同的库，那么这个库的代码会在每个程序的可执行文件中重复，从而占用更多的磁盘空间。

* **运行时库（Run-time Libraries）**：当程序启动时，操作系统会负责将运行时库加载到内存中，以便程序可以访问库中的函数和资源。共享库（例如 .so 文件在Unix-like系统中，或 .dll 文件在Windows中）就是一种典型的运行时库。
优点是多个程序可以共享同一份库文件，从而节省磁盘空间和内存。此外，更新共享库文件可以影响使用该库的所有程序，而无需重新编译这些程序。缺点是如果共享库在系统上缺失或版本不匹配，程序可能无法运行。

对于CUDA来说，CUDA Toolkit包含了CUDA的编译时库和运行时库。编译时库包括了CUDA的头文件和一些用于编译CUDA代码的工具，如nvcc编译器；运行时库包括了CUDA的动态链接库，这些库在运行CUDA程序时被加载。



## 编译/链接

静态链接和动态链接是两种不同的程序链接方式，是否生成自包含可执行的二进制文件看作是静态链接和动态链接的分界线。静态链接主要由编译器（更准确地说是链接器，它是编译器套件的一部分）完成。动态链接则主要由操作系统的动态链接器（也称为加载器）完成。

#### 静态链接：

1. **编译**：源代码被编译器编译成对象文件。每个源文件生成一个对象文件，这些文件包含了源文件中定义的函数和变量的机器代码。

2. **解析符号引用**：链接器查看所有的对象文件和库，找出所有的符号引用（例如函数调用和全局变量引用）。链接器会找出这些符号在哪个对象文件或库中定义，并将引用替换为这些定义的地址。

3. **合并**：链接器将所有的对象文件和库合并成一个单独的可执行文件。这个文件包含了所有的代码和数据，以及程序运行所需的信息（例如程序入口点的位置）。

4. **重定位**：由于合并过程可能会改变代码和数据的位置，链接器需要更新所有的地址引用，使它们指向正确的位置。这个过程称为重定位。

#### 动态链接：

1. **编译**：源代码被编译器编译成对象文件。这个过程和静态链接的编译过程是一样的。

2. **生成动态链接库**：链接器将一些对象文件链接成一个动态链接库（例如.so文件在Unix系统，.dll文件在Windows系统）。这个库包含了这些对象文件的代码和数据，但不包含主程序代码。

3. **生成可执行文件**：链接器将主程序的对象文件链接成一个可执行文件。这个文件包含了主程序的代码和数据，以及对动态链接库的引用，但不包含库的代码和数据。

4. **运行时链接**：当程序运行时，动态链接器（也称为加载器）会加载程序所需的动态链接库，并将程序中的库引用替换为库中的实际地址。这个过程在程序每次运行时都会发生。

静态链接的优点是生成的可执行文件是自包含的，不依赖于外部的库，因此更易于分发。而动态链接的优点是多个程序可以共享同一个库，节省内存和磁盘空间，且当库更新时，程序无需重新链接。
 


## 共享资源技术

共享内存对象、tmpfs 文件系统和共享库 .so 都是 Linux 系统中常见的技术，但它们的用途和工作方式有所不同。

*共享内存对象*：这是一种进程间通信（IPC）机制，允许两个或更多进程共享一块内存区域。共享内存是最快的 IPC 方法，因为它允许两个进程直接读写同一块内存区域，无需进行复制或上下文切换。在 Linux 中，共享内存对象可以通过 shmget、shmat 和 shmdt 等系统调用进行创建和管理。

*tmpfs 文件系统*：这是一种使用内存作为存储介质的文件系统。tmpfs 文件系统中的文件实际上是存储在 RAM 或交换空间中的，因此读写速度非常快。tmpfs 文件系统常用于存储临时文件，例如 /tmp 或 /run 目录。虽然 tmpfs 文件系统中的文件存储在内存中，但是它们表现得就像存储在磁盘上的普通文件一样，可以使用常规的文件 I/O 系统调用进行操作。

*共享库 .so*：这是一种包含可由多个程序共享的代码和数据的二进制文件。当一个程序被链接到一个共享库时，它并不需要将库中的所有代码和数据复制到自身的二进制文件中，而是在运行时动态地加载和链接这些代码和数据。这可以减少程序的大小，并允许在不重启程序的情况下更新库。在 Linux 中，共享库文件通常有 .so（Shared Object）扩展名。

总的来说，这三种技术都涉及到共享资源（内存或代码），但它们的用途和工作方式有所不同

## 命名管道 (FIFO) 
### 背景
*进程间通信*：命名管道是一种在不相关的进程之间进行通信的简单机制。
*父子进程变量隔离*：在 Bash 中，当您在后台 (&) 启动一个进程时，该进程成为一个新的子 shell 实例，与父进程隔离。这意味着父子进程之间的变量是隔离的，不能直接共享。
### 堵塞
*写入端*：如果没有进程连接到管道的读取端，那么尝试写入管道的进程会被阻塞。
*读取端*：如果没有数据在管道中，并且没有进程连接到管道的写入端，那么尝试从管道读取的进程会被阻塞。
### 使用
```shell
mkfifo /tmp/my_pipe
echo "Some data" > /tmp/my_pipe
cat < /tmp/my_pipe

```






